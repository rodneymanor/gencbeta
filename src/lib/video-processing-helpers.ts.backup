import { uploadToBunnyStream } from "@/lib/bunny-stream";
import {
  fetchInstagramMetadata,
  extractMetricsFromMetadata,
  extractAdditionalMetadata,
  downloadVideoFromVersions,
  extractThumbnailUrl,
} from "@/lib/instagram-downloader";
import { transcribeVideoFile } from "@/lib/transcription";

export interface DownloadResult {
  videoData: { buffer: ArrayBuffer; size: number; mimeType: string; filename?: string };
  metrics?: { likes: number; views: number; shares: number; comments: number; saves: number };
  additionalMetadata?: { author: string; duration: number };
  thumbnailUrl?: string;
}

export interface CdnResult {
  cdnUrl: string;
  filename: string;
}

export interface TranscriptionResult {
  success: boolean;
  transcript: string;
  platform: string;
  components: {
    hook: string;
    bridge: string;
    nugget: string;
    wta: string;
  };
  contentMetadata: {
    platform: string;
    author: string;
    description: string;
    source: string;
    hashtags: string[];
  };
  visualContext: string;
  transcriptionMetadata: {
    method: string;
    fileSize: number;
    fileName: string;
    processedAt: string;
  };
}

// Simple in-memory cache for TikTok API responses (24 hour TTL)
const tiktokCache = new Map<string, { data: unknown; timestamp: number }>();
const CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours

export function detectPlatform(url: string): string {
  const urlLower = url.toLowerCase();
  console.log("üîç [PLATFORM] Analyzing URL for platform detection:", urlLower);

  if (urlLower.includes("tiktok.com")) {
    console.log("‚úÖ [PLATFORM] Platform identified: TikTok");
    return "tiktok";
  }
  if (urlLower.includes("instagram.com")) {
    console.log("‚úÖ [PLATFORM] Platform identified: Instagram");
    return "instagram";
  }

  console.log("‚ö†Ô∏è [PLATFORM] Platform unknown for URL:", urlLower);
  return "unknown";
}

export async function transcribeVideoData(
  videoData: {
    buffer: ArrayBuffer;
    size: number;
    mimeType: string;
    filename?: string;
  },
  platform: string,
): Promise<TranscriptionResult | null> {
  try {
    console.log("üé¨ [DOWNLOAD] Converting video data to file for transcription...");

    const uint8Array = new Uint8Array(videoData.buffer);
    const blob = new Blob([uint8Array], { type: videoData.mimeType });
    const file = new File([blob], videoData.filename ?? `${platform}-video.mp4`, {
      type: videoData.mimeType,
    });

    console.log("üé¨ [DOWNLOAD] Transcribing video file...");
    // Use localhost for server-side transcription calls
    const baseUrl = process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : "http://localhost:3000";
    const transcriptionResult = await transcribeVideoFile(file, baseUrl);

    return transcriptionResult;
  } catch (error) {
    console.error("‚ùå [DOWNLOAD] Transcription error:", error);
    console.log("üîÑ [DOWNLOAD] Using fallback transcription due to API error");

    // Return fallback transcription so video can still be added to collection
    return createFallbackTranscription(platform);
  }
}

function createFallbackTranscription(platform: string): TranscriptionResult {
  return {
    success: true,
    transcript:
      "Transcription temporarily unavailable. Video content analysis will be available once transcription service is configured.",
    platform: platform,
    components: {
      hook: "Video content analysis pending",
      bridge: "Transcription service configuration needed",
      nugget: "Main content insights will be available after transcription",
      wta: "Configure Gemini API key to enable full video analysis",
    },
    contentMetadata: {
      platform: platform,
      author: "Unknown",
      description: "Video added successfully - transcription pending service configuration",
      source: "other",
      hashtags: [],
    },
    visualContext: "Visual analysis will be available once transcription service is configured",
    transcriptionMetadata: {
      method: "fallback",
      fileSize: 0,
      fileName: "fallback-transcription",
      processedAt: new Date().toISOString(),
    },
  };
}

export async function uploadToBunnyCDN(videoData: {
  buffer: ArrayBuffer;
  size: number;
  mimeType: string;
  filename?: string;
}): Promise<CdnResult | null> {
  try {
    console.log("üê∞ [DOWNLOAD] Uploading to CDN...");

    if (videoData.buffer.byteLength === 0) {
      console.error("‚ùå [DOWNLOAD] No video buffer data available");
      return null;
    }

    const buffer = Buffer.from(videoData.buffer);
    const result = await uploadToBunnyStream(buffer, videoData.filename ?? "video.mp4", videoData.mimeType);

    if (result) {
      console.log("‚úÖ [DOWNLOAD] CDN upload successful");
    } else {
      console.error("‚ùå [DOWNLOAD] CDN upload failed");
    }

    return result;
  } catch (error) {
    console.error("‚ùå [DOWNLOAD] CDN upload error:", error);
    return null;
  }
}

export async function downloadTikTokVideo(
  url: string,
): Promise<{ buffer: ArrayBuffer; size: number; mimeType: string; filename?: string } | null> {
  console.log("üéµ [DOWNLOAD] Downloading TikTok video via RapidAPI...");

  const videoId = extractTikTokVideoId(url);
  if (!videoId) {
    console.error("‚ùå [DOWNLOAD] Could not extract TikTok video ID from URL:", url);
    throw new Error("Invalid TikTok URL format. Please check the URL and try again.");
  }

  console.log("üÜî [DOWNLOAD] TikTok video ID:", videoId);

  try {
    // Check cache first
    const cacheKey = `tiktok_${videoId}`;
    const cached = tiktokCache.get(cacheKey);

    let metadata;
    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
      console.log("üíæ [DOWNLOAD] Using cached TikTok metadata");
      metadata = cached.data;
    } else {
      console.log("üåê [DOWNLOAD] Fetching TikTok metadata from RapidAPI...");

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);

      const metadataResponse = await fetch(
        `https://tiktok-scrapper-videos-music-challenges-downloader.p.rapidapi.com/video/${videoId}`,
        {
          method: "GET",
          headers: {
            "x-rapidapi-key": process.env.RAPIDAPI_KEY || "",
            "x-rapidapi-host": "tiktok-scrapper-videos-music-challenges-downloader.p.rapidapi.com",
          },
          signal: controller.signal,
        },
      );

      clearTimeout(timeoutId);

      if (!metadataResponse.ok) {
        const errorText = await metadataResponse.text();
        console.error("‚ùå [DOWNLOAD] TikTok RapidAPI error:", metadataResponse.status, errorText);

        if (metadataResponse.status === 429) {
          throw new Error(
            "TikTok download service temporarily unavailable due to rate limits. Please try again in a few minutes.",
          );
        } else if (metadataResponse.status === 404) {
          throw new Error("TikTok video not found. The video may be private, deleted, or the URL is incorrect.");
        } else {
          throw new Error("TikTok download service is currently unavailable. Please try again later.");
        }
      }

      metadata = await metadataResponse.json();

      // Cache the response
      tiktokCache.set(cacheKey, { data: metadata, timestamp: Date.now() });

      // Clean up old cache entries periodically
      if (tiktokCache.size > 100) {
        const now = Date.now();
        for (const [key, value] of tiktokCache.entries()) {
          if (now - value.timestamp > CACHE_TTL) {
            tiktokCache.delete(key);
          }
        }
      }
    }

    // Extract video data from response
    const videoData = metadata.data?.aweme_detail?.video;
    const videoUrls = videoData?.play_addr?.url_list;

    if (!videoUrls || videoUrls.length === 0) {
      console.error("‚ùå [DOWNLOAD] No video URLs found in TikTok response");
      throw new Error("Unable to extract video download links. The video may be private or restricted.");
    }

    console.log("üîó [DOWNLOAD] Found", videoUrls.length, "TikTok video quality options");

    // Prioritize lowest quality (last URL in the list typically)
    const prioritizedUrls = [...videoUrls].reverse();

    // Try each video URL starting with lowest quality
    for (let i = 0; i < prioritizedUrls.length; i++) {
      const videoUrl = prioritizedUrls[i];

      try {
        console.log(`üì• [DOWNLOAD] Attempting download from quality option ${i + 1}/${prioritizedUrls.length}`);

        const videoController = new AbortController();
        const videoTimeoutId = setTimeout(() => videoController.abort(), 20000);

        const videoResponse = await fetch(videoUrl, {
          headers: {
            "User-Agent":
              "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            Referer: "https://www.tiktok.com/",
          },
          signal: videoController.signal,
        });

        clearTimeout(videoTimeoutId);

        if (videoResponse.ok) {
          const buffer = await videoResponse.arrayBuffer();
          const size = buffer.byteLength;
          const mimeType = videoResponse.headers.get("content-type") || "video/mp4";

          if (size > 1000) {
            // Ensure we got actual video data
            console.log(
              `‚úÖ [DOWNLOAD] Successfully downloaded TikTok video (${Math.round((size / 1024 / 1024) * 100) / 100}MB)`,
            );

            return {
              buffer,
              size,
              mimeType,
              filename: `tiktok-${videoId}.mp4`,
            };
          }
        }
      } catch (error) {
        console.log(`‚ùå [DOWNLOAD] Quality option ${i + 1} failed:`, error);
        continue;
      }
    }

    throw new Error("Unable to download video from any available quality options. Please try again later.");
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") {
      throw new Error("TikTok download timed out. Please check your connection and try again.");
    }

    // Re-throw our custom errors, or wrap unknown errors
    if (error instanceof Error && error.message.includes("TikTok")) {
      throw error;
    }

    console.error("‚ùå [DOWNLOAD] TikTok download error:", error);
    throw new Error("Failed to download TikTok video. Please check the URL and try again.");
  }
}

export function extractTikTokVideoId(url: string): string | null {
  const patterns = [
    /tiktok\.com\/@[^/]+\/video\/(\d+)/,
    /vm\.tiktok\.com\/([A-Za-z0-9]+)/,
    /tiktok\.com\/t\/([A-Za-z0-9]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  return null;
}

export function extractInstagramShortcode(url: string): string | null {
  const match = url.match(/(?:instagram\.com|instagr\.am)\/(?:p|reels?)\/([A-Za-z0-9_-]+)/);
  return match ? match[1] : null;
}

export async function downloadInstagramVideoWithMetrics(url: string): Promise<DownloadResult | null> {
  const shortcode = extractInstagramShortcode(url);
  if (!shortcode) {
    console.error("‚ùå [DOWNLOAD] Could not extract Instagram shortcode");
    return null;
  }

  console.log("üÜî [DOWNLOAD] Instagram shortcode:", shortcode);

  try {
    console.log("üì± [DOWNLOAD] Fetching Instagram metadata...");
    const metadata = await fetchInstagramMetadata(shortcode);

    if (!metadata) {
      console.log("‚ùå [DOWNLOAD] No metadata returned, falling back to basic download");
      return await fallbackToBasicDownload();
    }

    console.log("üìä [DOWNLOAD] Extracting metrics from metadata...");
    const metrics = extractMetricsFromMetadata(metadata);
    const additionalMetadata = extractAdditionalMetadata(metadata);
    const thumbnailUrl = extractThumbnailUrl(metadata);

    console.log("üé• [DOWNLOAD] Downloading video from versions...");
    const videoData = await downloadVideoFromVersions(metadata.video_versions, shortcode);

    if (!videoData) {
      console.log("‚ùå [DOWNLOAD] Failed to download video data");
      return null;
    }

    console.log("‚úÖ [DOWNLOAD] Successfully downloaded Instagram video with metrics:", metrics);
    console.log("üìã [DOWNLOAD] Additional metadata:", additionalMetadata);
    console.log("üñºÔ∏è [DOWNLOAD] Thumbnail URL:", thumbnailUrl ? "‚úÖ Found" : "‚ùå Not found");
    return { videoData, metrics, additionalMetadata, thumbnailUrl };
  } catch (error) {
    console.error("‚ùå [DOWNLOAD] Instagram RapidAPI error:", error);
    console.log("üîÑ [DOWNLOAD] Falling back to basic download...");
    return await fallbackToBasicDownload();
  }
}

async function fallbackToBasicDownload(): Promise<DownloadResult | null> {
  // Simplified fallback - just return null for now
  console.log("üîÑ [DOWNLOAD] Basic download fallback not implemented");
  return null;
}
